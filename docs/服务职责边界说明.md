# Nova-X 服务职责边界说明

## 1. 基础设施层服务职责

### gateway-service - API 网关
**单一职责**：统一入口流量管理
- ✅ 负责：路由转发、协议转换、流量控制、灰度发布
- ✅ 负责：前置认证（Token 验证调用 auth-service）
- ❌ 不负责：Token 签发（由 auth-service 负责）
- ❌ 不负责：业务逻辑处理

### auth-service - 认证授权中心
**单一职责**：身份认证与 Token 生命周期管理
- ✅ 负责：用户登录认证、Token 签发、Token 刷新
- ✅ 负责：OAuth2 服务端、会话管理、MFA 验证
- ❌ 不负责：Token 验证（由 common-security 提供工具）
- ❌ 不负责：用户业务数据（由 account-service 负责）

### monitor-service - 统一可观测性平台
**单一职责**：指标监控、日志聚合、链路追踪一体化解决方案
- ✅ 负责：Prometheus 指标采集、实时告警、性能分析
- ✅ 负责：健康检查聚合、SLA 监控
- ✅ 负责：ELK 日志聚合、日志检索、链路追踪查询
- ✅ 负责：日志归档、审计日志查询
- ❌ 不负责：日志采集（由 common-log 在应用侧完成）

> **说明**：原 log-service 的功能已整合到 monitor-service 中，采用 Prometheus + Grafana + ELK Stack 的统一可观测性方案，避免服务拆分过细带来的维护复杂度。

---

## 2. 业务服务职责边界

### device-service vs iot-gateway-service

| 维度     | device-service（静态）          | iot-gateway-service（动态）  |
| -------- | ------------------------------- | ---------------------------- |
| 职责定位 | 设备资产管理                    | 设备状态网关                 |
| 数据类型 | 元数据（不频繁变化）            | 实时状态（高频变化）         |
| 具体内容 | 设备档案、型号、配置参数        | 在线状态、实时功率、影子状态 |
| 写入频率 | 低频（设备入网时）              | 高频（5秒心跳）              |
| 存储方式 | MySQL 关系型                    | InfluxDB 时序库 + Redis      |
| 示例数据 | 设备 ID、制造商、型号、额定功率 | 当前功率、电流、电压、SOC    |
| OTA 升级 | ❌ 不负责                        | ✅ 负责推送                   |
| 协议适配 | ❌ 不涉及                        | ✅ OCPP/GB/T 解析             |

**数据流向**：
```
设备首次入网：
  → iot-gateway-service 接收 BootNotification
  → 调用 device-service 注册设备档案
  → device-service 返回设备配置

设备日常心跳：
  → iot-gateway-service 接收 Heartbeat
  → 更新 Redis 设备影子
  → 写入 InfluxDB 时序数据
  → 不调用 device-service（减少耦合）
```

### common-security vs auth-service

| 功能        | common-security（工具库） | auth-service（认证中心） |
| ----------- | ------------------------- | ------------------------ |
| Token 签发  | ❌                         | ✅                        |
| Token 验证  | ✅                         | ❌                        |
| 加密解密    | ✅                         | 使用 common-security     |
| 签名验证    | ✅                         | 使用 common-security     |
| OAuth2 端点 | ❌                         | ✅                        |
| 依赖关系    | 被所有服务依赖            | 只依赖 common-security   |

**使用场景**：
```java
// auth-service 中签发 Token
@Service
public class AuthService {
    @Autowired
    private JwtUtil jwtUtil; // 来自 common-security

    public String login(String username, String password) {
        // 验证用户名密码
        User user = validateUser(username, password);
        // 使用 common-security 的工具签发 Token
        return jwtUtil.generateToken(user);
    }
}

// 其他业务服务中验证 Token
@Component
public class TokenInterceptor {
    @Autowired
    private JwtUtil jwtUtil; // 来自 common-security

    public boolean preHandle(HttpServletRequest request) {
        String token = request.getHeader("Authorization");
        // 使用 common-security 的工具验证 Token
        return jwtUtil.validateToken(token);
    }
}
```

### common-log vs monitor-service

| 功能         | common-log（采集端） | monitor-service（聚合端） |
| ------------ | -------------------- | ------------------------- |
| TraceID 生成 | ✅                    | ❌                         |
| 日志切面     | ✅                    | ❌                         |
| 日志拦截器   | ✅                    | ❌                         |
| 本地日志文件 | ✅ 写入               | ❌ 不写入                  |
| ELK 聚合     | ❌                    | ✅                         |
| 日志检索     | ❌                    | ✅                         |
| 链路追踪     | ❌                    | ✅                         |
| 指标监控     | ❌                    | ✅                         |
| 实时告警     | ❌                    | ✅                         |

**数据流向**：
```
应用日志链路：
  1. common-log 在请求入口生成 TraceID
  2. common-log 通过 @Log 注解拦截方法调用
  3. common-log 将日志写入本地文件（/var/log/nova-x/）
  4. Filebeat 采集本地日志文件
  5. Filebeat 推送到 Kafka/Logstash
  6. monitor-service 从 Kafka 消费并写入 Elasticsearch
  7. monitor-service 提供检索 API 和 Grafana/Kibana 可视化
```

---

## 3. 公共模块 common-bff

### 创建目的
消除 5 个 BFF 服务的代码重复，提供统一的基础能力。

### 提供的能力
```
common-bff/
├── interceptor/
│   └── AuthInterceptor.java          # 统一认证拦截
├── validator/
│   └── ParamValidator.java           # 统一参数校验
├── response/
│   └── BffResponse.java              # 统一响应封装
├── aggregator/
│   └── BaseAggregator.java           # 数据聚合基类
└── config/
    └── BffConfig.java                # 公共配置
```

### 使用示例
```java
// bff-consumer 继承公共基础
@RestController
@RequestMapping("/api/v1/stations")
public class StationController extends BaseBffController {

    @Autowired
    private StationAggregator aggregator; // 继承 BaseAggregator

    @GetMapping("/{id}")
    public BffResponse<StationDetail> getStation(@PathVariable Long id) {
        // 自动使用 AuthInterceptor 验证 Token
        // 自动使用 ParamValidator 验证参数
        StationDetail detail = aggregator.aggregateStationDetail(id);
        return BffResponse.success(detail);
    }
}
```

---

## 4. 事件驱动解耦原则

### 核心原则
- **同步调用**：仅用于关键路径（支付、启充、停充）
- **异步事件**：用于非关键路径（通知、积分、统计、报表）

### 事件消费者注册表

| Kafka Topic         | 生产者               | 消费者                                                | 用途           |
| ------------------- | -------------------- | ----------------------------------------------------- | -------------- |
| account-events      | account-service      | member-service, notification-service                  | 用户注册后处理 |
| device-events       | iot-gateway-service  | monitor-service, work-order-service                   | 设备异常告警   |
| session-events      | session-service      | billing-service, notification-service, report-service | 充电流程事件   |
| billing-events      | billing-service      | settlement-service, report-service                    | 账单生成       |
| payment-events      | payment-service      | session-service, member-service                       | 支付结果       |
| settlement-events   | settlement-service   | report-service                                        | 结算完成       |
| notification-events | notification-service | -                                                     | 通知发送请求   |

### 解耦效果对比

**原设计（紧耦合）**：
```
session-service 停止充电接口被调用
  → 同步调用 billing-service.close()
  → 同步调用 settlement-service.split()
  → 同步调用 payment-service.deduct()
  → 同步调用 member-service.addPoints()
  → 同步调用 notification-service.send()
  → 返回给用户

问题：任何一个服务超时或故障，整个链路失败
耗时：1000ms（5个服务 × 200ms）
```

**新设计（解耦）**：
```
session-service 停止充电接口被调用
  → 更新会话状态为"已完成"
  → 发送 `session-completed` 事件到 Kafka
  → 立即返回给用户（200ms）

后续异步处理（互不影响）：
  ├─ billing-service 监听事件 → 计费封账 → 发送 `billing-completed`
  ├─ settlement-service 监听 `billing-completed` → 多方分账
  ├─ payment-service 监听 `billing-completed` → 扣款 → 发送 `payment-success`
  ├─ member-service 监听 `payment-success` → 增加积分
  ├─ notification-service 监听 `session-completed` → 推送通知
  └─ report-service 监听 `session-completed` → 更新统计

优势：
1. 用户响应时间从 1000ms → 200ms
2. 单个服务故障不影响其他服务
3. 可独立扩展消费者数量
```

---

## 5. 依赖关系矩阵

### 服务间依赖（同步调用）

| 调用方              | 被调用方                 | 调用场景     | 是否必要   |
| ------------------- | ------------------------ | ------------ | ---------- |
| gateway-service     | auth-service             | Token 验证   | ✅ 必要     |
| session-service     | account-service          | 查询用户余额 | ✅ 必要     |
| session-service     | device-service           | 查询设备配置 | ✅ 必要     |
| session-service     | iot-gateway-service      | 下发启动指令 | ✅ 必要     |
| billing-service     | pricing-service          | 获取定价策略 | ✅ 必要     |
| ~~session-service~~ | ~~billing-service~~      | ~~实时计费~~ | ❌ 改为事件 |
| ~~session-service~~ | ~~notification-service~~ | ~~发送通知~~ | ❌ 改为事件 |

### 模块依赖（编译期）

```
所有微服务
  └─ 依赖 common-core（必须）
  └─ 依赖 common-log（必须）

需要认证的服务
  └─ 依赖 common-security

所有 BFF 服务
  └─ 依赖 common-bff
  └─ 依赖 common-security

使用缓存的服务
  └─ 依赖 common-redis

使用数据库的服务
  └─ 依赖 common-mybatis

使用消息队列的服务
  └─ 依赖 common-kafka
```

---

## 6. 总结

### 架构优化成果
✅ **解耦成功**：设备元数据与状态分离
✅ **职责清晰**：认证签发与验证分离
✅ **消除重复**：创建 common-bff 统一 BFF 基础能力
✅ **事件驱动**：长链路调用改为异步事件
✅ **边界明确**：每个服务单一职责，文档化职责边界

### 开发指导原则
1. **服务间通信**：优先使用事件，关键路径使用同步
2. **公共能力**：提取到 common 模块，避免重复
3. **数据分离**：静态元数据与动态状态物理隔离
4. **职责单一**：一个服务只做一件事，且做好
5. **依赖最小化**：减少服务间直接依赖，通过事件解耦
